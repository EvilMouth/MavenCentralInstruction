apply plugin: 'maven-publish'
apply plugin: 'signing'
apply plugin: 'org.jetbrains.dokka'

def isAndroid = project.plugins.hasPlugin("com.android.library")

task sourcesJar(type: Jar) {
    archiveClassifier.set("sources")
    if (isAndroid) {
        // For Android libraries
        from android.sourceSets.main.java.srcDirs
        from android.sourceSets.main.kotlin.srcDirs
    } else {
        // For pure Kotlin libraries, in case you have them
        from sourceSets.main.java.srcDirs
        from sourceSets.main.kotlin.srcDirs
    }
}

if (isAndroid) {
    dokkaHtml.configure {
        dokkaSourceSets {
            named("main") {
                noAndroidSdkLink.set(false)
            }
        }
    }
}

task javadocJar(type: Jar, dependsOn: dokkaJavadoc) {
    archiveClassifier.set("javadoc")
    from dokkaJavadoc.outputDirectory
}

artifacts {
    archives sourcesJar
    archives javadocJar
}

def PUBLISH_GROUP_ID = PUBLISH_GROUP_ID
def PUBLISH_ARTIFACT_ID = extOrProperty("PUBLISH_ARTIFACT_ID", project.name)
def PUBLISH_VERSION = PUBLISH_VERSION

group = PUBLISH_GROUP_ID
version = PUBLISH_VERSION

afterEvaluate {
    publishing {
        publications {
            release(MavenPublication) {
                // The coordinates of the library, being set from variables that
                // we'll set up later
                groupId PUBLISH_GROUP_ID
                artifactId PUBLISH_ARTIFACT_ID
                version PUBLISH_VERSION

                // Two artifacts, the `aar` (or `jar`) and the sources
                if (isAndroid) {
                    from components.release
                } else {
                    from components.java
                }

                artifact sourcesJar
                artifact javadocJar

                // Mostly self-explanatory metadata
                pom {
                    name = extOrProperty("PUBLISH_NAME", PUBLISH_ARTIFACT_ID)
                    description = extOrProperty("PUBLISH_DESCRIPTION", "$PUBLISH_GROUP_ID:$PUBLISH_ARTIFACT_ID:$PUBLISH_VERSION")
                    url = extOrProperty("PUBLISH_URL", removeSuffix(getGitHttpUrl(), ".git"))
                    licenses {
                        license {
                            name = extOrProperty("PUBLISH_LICENSE_NAME", "APACHE LICENSE, VERSION 2.0")
                            url = extOrProperty("PUBLISH_LICENSE_URL", "https://www.apache.org/licenses/LICENSE-2.0")
                        }
                    }
                    developers {
                        developer {
                            id = extOrProperty("PUBLISH_DEVELOPER_ID", PUBLISH_GROUP_ID)
                            name = extOrProperty("PUBLISH_DEVELOPER_NAME", getGitUserName())
                            email = extOrProperty("PUBLISH_DEVELOPER_EMAIL", getGitUserEmail())
                        }
                        // Add all other devs here...
                    }

                    // Version control info - if you're using GitHub, follow the
                    // format as seen here
                    scm {
                        connection = extOrProperty("PUBLISH_SCM_CONNECTION", "scm:git:" + getGitUrlComposition())
                        developerConnection = extOrProperty("PUBLISH_SCM_DEVELOPERCONNECTION", "scm:git:ssh://" + getGitUrlComposition())
                        url = extOrProperty("PUBLISH_SCM_URL", removeSuffix(getGitHttpUrl(), ".git"))
                    }
                }
            }
        }

        repositories {
            maven {
                name = "GitHubPackages"
                url = "https://maven.pkg.github.com/" + System.getenv("GITHUB_REPOSITORY")
                credentials {
                    username = System.getenv("GITHUB_ACTOR")
                    password = System.getenv("GITHUB_TOKEN")
                }
            }
        }
    }
}

if (!PUBLISH_VERSION.endsWith("-SNAPSHOT")) {
    signing {
        useInMemoryPgpKeys(
                rootProject.ext["signing.keyId"],
                rootProject.ext["signing.key"],
                rootProject.ext["signing.password"],
        )
        sign publishing.publications
    }
}

/// utils

Object extOrProperty(String key, String defaultValue = "") {
    return project.ext.find(key) ?: findProperty(key) ?: defaultValue
}

/**
 * git@github.com:EvilMouth/MavenCentralInstruction.git
 * or
 * https://github.com/EvilMouth/MavenCentralInstruction.git
 */
static String getGitUrl() {
    try {
        String url = "git remote get-url origin".execute().text.trim()
        if (url.startsWith("http") && url.contains("@")) {
            // remove username and password for security
            def protocol = url.split("://")[0]
            def suffix = url.split("@")[1]
            url = protocol + "://" + suffix
        }
        return url
    } catch (ignored) {
        return ""
    }
}

/**
 * https://github.com/EvilMouth/MavenCentralInstruction.git
 */
static String getGitHttpUrl() {
    def url = getGitUrl()
    if (url.startsWith("git@")) {
        return "https://" + getGitUrlComposition()
    } else {
        return url
    }
}

/**
 * github.com/EvilMouth/MavenCentralInstruction.git
 */
static String getGitUrlComposition() {
    def url = getGitUrl()
    if (url.startsWith("git@")) {
        def arr = url.replace("git@", "").split(":")
        return arr[0] + "/" + arr[1]
    } else if (url.startsWith("http")) {
        return url.split("//")[1]
    } else {
        return url
    }
}

static String removeSuffix(String source, String suffix) {
    if (source.endsWith(suffix)) {
        return source.substring(0, source.length() - suffix.length())
    } else {
        return source
    }
}

static String getGitUserName() {
    try {
        return "git config --get user.name".execute().text.trim()
    } catch (ignored) {
        return ""
    }
}

static String getGitUserEmail() {
    try {
        return "git config --get user.email".execute().text.trim()
    } catch (ignored) {
        return ""
    }
}